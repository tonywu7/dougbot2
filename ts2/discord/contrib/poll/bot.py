# bot.py
# Copyright (C) 2021  @tonyzbf +https://github.com/tonyzbf/
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import asyncio
import base64
import logging
import re
from contextlib import suppress
from datetime import datetime, timezone
from textwrap import dedent
from typing import Literal, Optional, Union
from urllib.parse import parse_qs, urlencode, urlsplit, urlunsplit

import attr
import inflect
import simplejson as json
from discord import (AllowedMentions, Emoji, File, Guild, HTTPException,
                     Member, Message, PartialEmoji, PartialMessage,
                     RawBulkMessageDeleteEvent, RawMessageDeleteEvent,
                     RawReactionActionEvent, Role, TextChannel)
from discord.ext.commands import (BotMissingPermissions, BucketType,
                                  EmojiConverter, EmojiNotFound,
                                  MissingAnyRole, group)
from django.core.cache import caches
from django.utils.datastructures import MultiValueDict
from more_itertools import chunked, first, map_reduce, split_before

from ts2.discord.cog import Gear
from ts2.discord.context import Circumstances, on_error_reset_cooldown
from ts2.discord.ext import autodoc as doc
from ts2.discord.ext.autodoc import NotAcceptable
from ts2.discord.ext.common import Constant
from ts2.discord.utils.async_ import async_get, async_list
from ts2.discord.utils.common import (E, Embed2, EmbedField, EmbedPagination,
                                      a, assumed_utc, blockquote, can_embed,
                                      chapterize, code, iter_urls, pre, strong,
                                      tag, tag_literal, timestamp, utcnow)

from .models import SuggestionChannel

EmoteType = Union[Emoji, PartialEmoji, str]

inflection = inflect.engine()


def _default_int(v, default=0) -> int:
    try:
        return int(v)
    except Exception:
        return 0


@attr.s(frozen=True, slots=True)
class Vote:
    """A vote submitted to a poll."""

    user_id: int = attr.ib(converter=int)
    created: float = attr.ib(converter=float)
    emote: str = attr.ib()
    text: Optional[str] = attr.ib(default=None)


@attr.s(frozen=True, slots=True)
class Comment:
    """A comment added to a poll."""

    user_id: int = attr.ib(converter=int)
    created: float = attr.ib(converter=float)
    content: str = attr.ib()


@attr.s(frozen=True, slots=True)
class EditTime:
    """A timestamp indicating who and when a poll was edited."""

    user_id: int = attr.ib(converter=int)
    modified: float = attr.ib(converter=float)


class Poll:
    """A question or prompt for gathering opinions.

    A Poll object keep information about the opinion poll: its title, prompt,
    optionally an author, and available choices. It exports them as an embed
    to be sent on Discord.

    Each choice is a short text associated with an emote, which will be added
    as reactions on the embed for people to vote on.

    Polls keep track of all casted votes including the times and users who
    voted for an option. The votes are presented in the embed as well.

    Poll objects can be pickled for caching, but the cached object is expendable.
    It is possible to recreate a Poll object from a poll embed as long as the embed
    is valid (generated by a Poll object).
    """

    RE_VOTE = re.compile((
        r'^(?P<emote>\S+) \*\*(?P<text>.*)\*\* - '
        r'<@(?P<user_id>\d+)> <t:(?P<created>\d+).*>$'
    ), re.MULTILINE)
    RE_EDIT_TIME = re.compile((
        r'^<@(?P<user_id>\d+)> <t:(?P<modified>\d+).*>$'
    ), re.MULTILINE)
    RE_COMMENT = re.compile((
        r'^<@(?P<user_id>\d+)> <t:(?P<created>\d+).*>:'
        r' (?P<content>.+)$'
    ), re.MULTILINE)
    RE_OBFUSCATION = re.compile(r'\[\(anonymous\)\]\((?P<id>\d+)\)')

    def __init__(
        self, content: str, choices: dict[EmoteType, Optional[str]],
        *, author: str = 'unknown', title: str = 'Poll',
    ):
        """Create a poll.

        :param content: Main body of the prompt
        :type content: str
        :param choices: Available choices, must be an emote-to-string
        mapping
        :type choices: dict[EmoteType, Optional[str]]
        :param author: Author of this poll, can be any text,
        defaults to 'unknown'
        :type author: str, optional
        :param title: Title of this poll, to be used as the embed title,
        defaults to 'Poll'
        :type title: str, optional
        """
        self.title = title
        self.author = author
        self.content = content
        self.choices = {**choices}

        self.origin_url: str = 'https://discord.com'
        self.linked_msg: int = 0

        self.author_id: int = 0
        self.author_icon: str = ''
        self.attrib_id: int = 0

        self.color: int = 0
        self.created: float = utcnow().timestamp()

        self.votes: list[Vote] = []
        self.comments: list[Comment] = []
        self.edits: list[EditTime] = []

        self.single_choice = False
        self.forum = False
        self.obfuscated = False

    @classmethod
    def from_embed(cls, embed: Embed2):
        """Recreate a Poll object from a poll embed."""
        title = embed.title
        content = embed.description
        author = embed.author.name
        url = urlsplit(embed.author.url)
        config = MultiValueDict(parse_qs(url.query))
        choices = json.loads(base64.urlsafe_b64decode(config['options']).decode('utf8'))
        poll = cls(content, choices, author=author, title=title)

        poll.origin_url = urlunsplit((url.scheme, url.netloc, url.path, '', ''))
        poll.load_config(config)

        poll.load_votes(embed.get_field_value('Response'))
        poll.load_comments(embed.get_field_value('Comments'))
        poll.load_edits(embed.get_field_value('Edited'))

        if embed.timestamp:
            poll.created = assumed_utc(embed.timestamp).timestamp()
        poll.author_icon = embed.author.icon_url or ''
        poll.color = embed.color.value or poll.color

        return poll

    def __setstate__(self, state):
        self.__dict__ = state
        self.__dict__.setdefault('single_choice', False)
        self.__dict__.setdefault('forum', False)
        self.__dict__.setdefault('obfuscated', False)

    def deobfuscate(self, text: str) -> str:
        """Make usernames in the text hidden by the obfuscate function visible again."""
        return self.RE_OBFUSCATION.sub(r'<@\g<id>>', text)

    def load_config(self, config: dict):
        """Set properties of this poll using this dictionary, handling missing keys."""
        self.linked_msg = _default_int(config.get('linked'))
        self.author_id = _default_int(config.get('author'))
        self.attrib_id = _default_int(config.get('attrib'))
        self.single_choice = bool(_default_int(config.get('single')))
        self.forum = bool(_default_int(config.get('forum')))
        self.obfuscated = bool(_default_int(config.get('anon')))

    def load_votes(self, text: str):
        """Parse casted votes from text (the "Response" field) and add them to this poll."""
        text = self.deobfuscate(text)
        self.votes = [Vote(**v.groupdict()) for v
                      in self.RE_VOTE.finditer(text)]

    def load_comments(self, text: str):
        """Parse added comments from text (the "Comments" field) and add them to this poll."""
        text = self.deobfuscate(text)
        self.comments = [Comment(**c.groupdict()) for c
                         in self.RE_COMMENT.finditer(text)]

    def load_edits(self, text: str):
        """Parse edit timestamps (the "Edits" field) and add them to this poll."""
        text = self.deobfuscate(text)
        self.edits = [EditTime(**e.groupdict()) for e
                      in self.RE_EDIT_TIME.finditer(text)]

    def vote(self, member: Member, option: EmoteType):
        """Add a vote to this poll."""
        emote = str(option)
        try:
            text = self.choices[emote]
        except KeyError:
            raise ValueError(f'Invalid option {option}')
        self.votes.append(Vote(member.id, utcnow().timestamp(), emote, text))
        if self.single_choice:
            unique_votes = {v.user_id: v for v in self.votes}
            self.votes = [*unique_votes.values()]

    def comment(self, member: Member, content: str):
        """Add a comment to this poll."""
        self.comments.append(Comment(member.id, utcnow().timestamp(), content))

    def edit(self, member: Member, content: str):
        """Update the poll's content and record the edit timestamp."""
        self.content = content
        self.touch(member)

    def touch(self, member: Member):
        """Update the modification time for this poll."""
        self.edits.append(EditTime(member.id, utcnow().timestamp()))

    def set_origin(self, msg: Message):
        """Set the message that created this poll (usually a command call)."""
        self.origin_url = msg.jump_url

    def set_linked(self, msg: Message):
        """Set the message whose content is associated with this poll (usually content that\
        needs to be displayed separately e.g. external embeds)."""
        self.linked_msg = msg.id

    def set_credit(self, member: Member):
        """Update the creator of the poll.

        This will also set the author icon and color of the embed.
        """
        self.author = str(member)
        self.attrib_id = member.id
        self.author_icon = str(member.avatar_url)
        self.color = member.color.value

    def set_author(self, member: Member):
        """Update the author of the poll.

        This sets the `author_id` which allows the poll to be edited by
        this member.
        """
        self.set_credit(member)
        self.author_id = member.id

    def get_user_display(self, user_id: int) -> str:
        """Format a user mention depending on whether the poll should anonymize usernames or not."""
        if self.obfuscated:
            return a('(anonymous)', user_id)
        else:
            return tag_literal('user', user_id)

    def get_external_links(self) -> list[str]:
        """Find all URLs in the poll content.

        This is used to e.g. send all links in a separate message so that
        their embeds will appear.
        """
        return [*iter_urls(self.content)]

    def gen_permalink(self, message: Message) -> EmbedField:
        """Get the link to this message (which contains the embed for this poll)\
        as an embed field to be added to the embed itself later."""
        permalink = a(strong('Permalink'), message.jump_url)
        return EmbedField('Reference', permalink, False)

    def gen_votes(self) -> EmbedField:
        """Print all votes casted for this poll as an embed field."""
        lines: list[str] = []
        for v in self.votes:
            if not v.text:
                continue
            lines.append(
                f'{v.emote} {strong(v.text)}'
                f' - {self.get_user_display(v.user_id)}'
                f' {timestamp(v.created, "relative")}',
            )
        return EmbedField('Response', '\n'.join(lines), False)

    def gen_comments(self) -> EmbedField:
        """Print all comments added to this poll as an embed field."""
        lines = []
        for c in self.comments:
            lines.append(
                f'{self.get_user_display(c.user_id)}'
                f' {timestamp(c.created, "relative")}'
                f': {c.content}',
            )
        return EmbedField('Comments', '\n'.join(lines), False)

    def gen_history(self) -> EmbedField:
        """Print all modification timestamps as an embed field."""
        lines = []
        for edit in self.edits:
            lines.append(
                f'{self.get_user_display(edit.user_id)}'
                f' {timestamp(edit.modified, "relative")}',
            )
        return EmbedField('Edited', '\n'.join(lines), False)

    def gen_forum(self) -> EmbedField:
        """Print a notice indicating that the poll's comment is open for everyone."""
        indicator = strong(
            f'{E("star")} Comments section for this submission is open.'
            f'\nAnyone can add a comment by using the {code("suggest comment")} command.',
        )
        return EmbedField('Forum', indicator, False)

    def to_url(self) -> str:
        """Export the poll's settings as a URL.

        The URL will be the link to the `origin` of this poll, and settings
        are serialized as URL parameters.
        """
        params = {
            'linked': self.linked_msg,
            'author': self.author_id,
            'attrib': self.attrib_id,
            'single': int(self.single_choice),
            'forum': int(self.forum),
            'anon': int(self.obfuscated),
        }
        options = json.dumps(self.choices)
        params['options'] = base64.urlsafe_b64encode(options.encode()).decode('ascii')
        query = urlencode({k: v for k, v in params.items() if v})
        return urlunsplit((*urlsplit(self.origin_url)[:3], query, ''))

    def to_embed(self, message: Optional[Message] = None) -> Embed2:
        """Export this poll as an embed to be sent in a message."""
        fields = []
        if message:
            fields.append(self.gen_permalink(message))
        if self.votes:
            fields.append(self.gen_votes())
        if self.comments:
            fields.append(self.gen_comments())
        if self.edits:
            fields.append(self.gen_history())
        if self.forum:
            fields.append(self.gen_forum())
        title = self.title or 'Poll'
        content = self.content or '(no text content)'
        return (
            Embed2(title=title, description=content, fields=fields)
            .set_author(name=self.author, url=self.to_url(), icon_url=self.author_icon)
            .set_timestamp(self.timestamp)
            .set_color(self.color)
        )

    def can_update(self, member: Member) -> bool:
        """Check if this member is allowed to update the poll's content."""
        return member.id == self.author_id or member.id == self.attrib_id

    def can_delete(self, member: Member) -> bool:
        """Check if this member is allowed to delete the poll.

        This is used for e.g. the delete command.
        """
        return member.id == self.author_id

    @property
    def minor_choices(self) -> list[str]:
        """All choices that don't have a description (only emotes).

        Votes for these choices will not appear in the embed. The emotes are
        however present as reactions.
        """
        return [k for k, v in self.choices.items() if not v]

    @property
    def major_choices(self) -> dict[str, str]:
        """All choices that have text descriptions.

        Votes for these choices will appear in the embed showing who voted for the
        option and when.
        """
        return {k: v for k, v in self.choices.items() if v}

    @property
    def timestamp(self) -> datetime:
        """Get the creation time of this poll as a datetime object."""
        return datetime.fromtimestamp(self.created, timezone.utc)

    def tally(self, origin: Message, hide_username: bool = False) -> Embed2:
        """Count the number of votes casted and generate a report."""

        scores = {str(r.emoji): r.count - r.me for r in origin.reactions}
        scores = {k: scores.get(k, 0) for k in self.minor_choices}
        scores = {k: v for k, v in scores.items() if v}

        votes = map_reduce(
            self.votes, lambda v: f'{v.emote} {strong(v.text)}',
            lambda v: tag_literal('user', v.user_id),
            lambda vs: sorted(set(vs)),
        )

        lines = []
        for row in chunked(scores.items(), 6):
            lines.append('\n'.join([f'{code(v)} {k}' for k, v in row]))
        for k, v in votes.items():
            lines.append((f'{code(len(v))} {k}\n{blockquote(" ".join(v))}'
                          if not hide_username else f'{code(len(v))} {k}'))
        if lines:
            report = '\n'.join(lines)
        else:
            report = '(No vote casted)'

        polled = self.timestamp
        tallied = utcnow().timestamp()

        return (
            self.to_embed(origin)
            .clear_fields()
            .add_field(name='Polled', value=timestamp(polled, 'relative'))
            .add_field(name='Counted', value=timestamp(tallied, 'relative'))
            .add_field(name='Votes', value=report, inline=False)
            .set_timestamp()
        )


class Polling(
    Gear, name='Poll', order=20,
    description='Suggestions & polls',
):
    """Polling and suggestion system."""

    _CACHE_VERSION = 5
    _CACHE_TTL = 604800

    # TODO: remove
    RE_BALLOT_FORMAT = re.compile((
        r'^(?P<emote>\S+) \*\*(?P<response>.*)\*\* - '
        r'<@(?P<user_id>\d+)> <t:(?P<timestamp>\d+).*>$'
    ), re.M)
    RE_OBFUSCATED = re.compile(r'\[\(anonymous\)\]\((\d+)\)')

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._sequential = asyncio.Lock()
        self._cache = caches['discord']
        self._invalid: set[int] = set()
        self.log = logging.getLogger('discord.poll')

    async def list_suggest_channels(self, guild: Guild) -> str:
        """Print all suggestion channels for this guild."""
        channels = {c.id: c for c in guild.channels}
        q = SuggestionChannel.objects.filter(channel_id__in=channels)
        lines = []
        targets = sorted((
            (guild.get_channel(c.channel_id), c)
            for c in await async_list(q)
        ), key=lambda t: t[0].position)
        for ch, c in targets:
            c: SuggestionChannel
            lines.append(f'\n{tag(channels[c.channel_id])} {c.description}')
        return '\n'.join(lines).strip()

    async def send_channel_list(self, ctx: Circumstances):
        """Generate a help page for the suggestion command, including list of suggestion channels."""
        channel_list = await self.list_suggest_channels(ctx.guild)
        if not channel_list:
            channel_list = '(no suggest channels)'
        help_text = (
            f'{strong("See")} {E("fast_forward")} {strong("next page")}'
            f' {strong("for a list of available suggestion channels.")}'
            f'\n\nTo make a suggestion, call {code("suggest")},'
            ' followed by the suggestion channel,'
            ' followed by the content of your submission, e.g.: '
            f'{pre("suggest #discord-suggestions Enable threads")}'
            ' To upload images/files, upload it together with the command call.'
            '\nThe submission will include a "permalink," which you can use to'
            ' edit or delete your suggestion. For example, to edit your suggestion,'
            ' copy the link, then:'
            f'{pre("suggest edit (paste link here) (updated suggestion)")}'
        )
        channel_lists = chapterize(channel_list, 1280, lambda c: c == '\n')
        channel_lists = [f'{strong("Channels")}\n{channels}'
                         for channels in channel_lists]
        base = Embed2().decorated(ctx.guild)
        pages = [base.set_description(description=description)
                 for description in [help_text, *channel_lists]]
        pagination = EmbedPagination(pages, 'Suggestion channels')
        return await (ctx.response(ctx, embed=pagination).deleter()
                      .responder(pagination.with_context(ctx)).run())

    async def get_channel_or_404(self, ctx: Circumstances, channel: TextChannel):
        """Get the SuggestionChannel object associated with this guild channel.

        If the channel is not a suggestion channel, raise a NotAcceptable exception
        (UserInputError).
        """
        channels = [c.id for c in ctx.guild.channels]
        suggests = SuggestionChannel.objects.filter(channel_id__in=channels)
        try:
            suggest: SuggestionChannel = await async_get(suggests, channel_id=channel.id)
        except SuggestionChannel.DoesNotExist:
            raise NotAcceptable(f'{tag(channel)} is not a suggestion channel.')
        else:
            return suggest

    def get_cache_key(self, msg_id: int):
        """Get a unique key relevant to this cog for caching purposes.

        This is used for caching Poll objects.
        """
        return f'{__name__}:{self.app_label}:suggestion:{msg_id}'

    def cache_submission(self, msg_id: int, poll: Poll):
        """Cache a Poll object in memory (using Django cache).

        This is so that commands and reaction events needing this poll do not
        have to parse the embed every time they need it.

        In particular, the `raw_reaction_add` events (used for voting) do not
        provide message content, and caching means the bot doesn't need to
        pull the message from the cache (or worse: make a request to Discord)
        every time someone adds a reaction.
        """
        key = self.get_cache_key(msg_id)
        self._cache.set(key, poll, timeout=self._CACHE_TTL, version=self._CACHE_VERSION)

    def invalidate_submission(self, msg_id: int):
        """Remove a cached poll from memory."""
        key = self.get_cache_key(msg_id)
        self._cache.delete(key, version=self._CACHE_VERSION)

    def get_cached_submission(self, msg_id: int) -> Optional[Poll]:
        """Get a cached poll.

        Returns None on cache miss.
        """
        key = self.get_cache_key(msg_id)
        return self._cache.get(key, None, self._CACHE_VERSION)

    def parse_submission(self, msg: Message) -> Poll:
        """Recreate a Poll object from a message that may contain a poll embed.

        :raises NotPoll: if parsing failed, indicating that the message doesn't
        contain a valid poll embed.
        """
        if msg.author != self.bot.user:
            raise NotPoll(msg)
        embed = first(msg.embeds, None)
        if not embed:
            raise NotPoll(msg)
        embed = Embed2.upgrade(embed)
        try:
            return Poll.from_embed(embed)
        except Exception:
            raise NotPoll(msg)

    async def fetch_submission(self, msg: PartialMessage) -> Poll:
        """Get a Poll object from a message or a partial message."""
        msg_id = msg.id
        if msg_id in self._invalid:
            raise NotPoll(msg)
        channel = msg.channel
        poll = self.get_cached_submission(msg_id)
        if not poll:
            if isinstance(msg, PartialMessage):
                msg: Message = await channel.fetch_message(msg_id)
            try:
                poll = self.parse_submission(msg)
            except NotPoll:
                self._invalid.add(msg_id)
                raise
            self.cache_submission(msg_id, poll)
        return poll

    async def update_submission(self, poll: Poll, origin: PartialMessage,
                                *, linked: Optional[str] = None):
        """Edit the message containing an updated poll.

        Also edits the linked message (which contains any links and/or attachments
        submitted with the poll.
        """
        channel: TextChannel = origin.channel
        updated = poll.to_embed(origin)
        try:
            updated.check_oversized()
        except ValueError:
            raise NotAcceptable(
                'This submission has reached its max content size'
                ' and can no longer be modified.',
            )
        try:
            await origin.edit(embed=updated)
        except HTTPException as e:
            self.log.warning(f'Error while setting embed: {e}', exc_info=e)
        else:
            self.cache_submission(origin.id, poll)

        if linked:
            linked_msg = channel.get_partial_message(poll.linked_msg)
            with suppress(HTTPException):
                await linked_msg.edit(allowed_mentions=AllowedMentions.none(),
                                      content=linked)

    def get_suggestion_text(self, target: SuggestionChannel, content: str):
        """Ensure that suggestion content is not empty if the suggestion channel requires it."""
        if target.requires_text and not content:
            raise NotAcceptable((
                f'Submissions to {tag_literal("channel", target.channel_id)}'
                ' must contain text description:'
                ' what you would like to suggest?'
            ))
        return content

    def get_suggestion_links(self, target: SuggestionChannel, links: list[str]):
        """Find all URLs present in a suggestion.

        The extracted URLs are sent in a separate message so that Discord will display
        their embeds (e.g. YouTube players). This also ensure that the minimum # of
        links requirement of a suggestion channel is met.
        """
        min_links = target.requires_links
        if min_links and len(links) < min_links:
            err = (f'Submissions to {tag_literal("channel", target.channel_id)}'
                   f' must include at least {min_links}'
                   f' {inflection.plural_noun("link", min_links)}.')
            raise NotAcceptable(err)
        return links

    async def get_suggestion_files(self, target: SuggestionChannel, msg: Message) -> list[File]:
        """Get all submitted attachments as discord.File objects to be re-uploaded.

        This also ensures a submission meets the requirement of minimum # of files.
        """
        min_uploads = target.requires_uploads
        if min_uploads and len(msg.attachments) < min_uploads:
            err = (f'Submissions to {tag(msg.channel)} require'
                   f' uploading at least {min_uploads}'
                   f' {inflection.plural_noun("file", min_uploads)}.')
            raise NotAcceptable(err)
        return await asyncio.gather(*[att.to_file() for att in msg.attachments])

    def get_preamble(
        self, target: SuggestionChannel,
        author_id: int, links: list[str],
    ) -> str:
        """Format the beginning of a suggestion.

        Currently this will mention the title (what kind) of the suggestion,
        as well as who submitted it.
        """
        prefix = f'{target.title} submitted by {tag_literal("member", author_id)}:'
        return '\n'.join([prefix, *links])

    def is_arbiter_in(self, target: SuggestionChannel, member: Member) -> bool:
        """Check if a member has the permission to cast votes in a suggestion channel."""
        roles: list[Role] = member.roles
        return {r.id for r in roles} & set(target.arbiters)

    async def deliver(self, channel: TextChannel, **kwargs):
        """Send the submission.

        This method checks the bot's permission in the target channel
        and raises BotMissingPermissions if any are missing.
        """
        perms = channel.permissions_for(channel.guild.me)
        missing = []
        for required in ('send_messages', 'attach_files',
                         'embed_links', 'add_reactions'):
            if not getattr(perms, required):
                missing.append(required)
        if missing:
            exc = BotMissingPermissions(missing)
            exc.channel = channel
            raise exc
        return await channel.send(**kwargs)

    async def add_reactions(self, poll: Poll, msg: Message):
        """Add all emote choices as reactions to the message containing the poll."""
        for e in filter(None, poll.choices):
            with suppress(Exception):
                await msg.add_reaction(e)

    async def reset_votes(self, poll: Poll, msg: Message):
        """Remove all reactions that are poll choices from the message."""
        for emote in poll.major_choices:
            with suppress(Exception):
                await msg.clear_reaction(emote)

    async def respond(self, ctx: Circumstances, content: str):
        """Respond to command calls for commands in this cog.

        This uses the reply function and sets a 20-second autodelete.
        """
        return (await ctx.response(ctx, content=content)
                .reply().autodelete(20).run())

    @group('suggest', case_insensitive=True, invoke_without_command=True)
    @doc.description('Make a suggestion.')
    @doc.argument('category', 'The suggestion channel to use.',
                  node='[suggest channel]', signature='[channel]')
    @doc.argument('suggestion', 'Your suggestion here.')
    @doc.cooldown(1, 60, BucketType.member)
    @doc.use_syntax_whitelist
    @doc.invocation((), 'Show a list of all suggestion channels.')
    @doc.invocation(('category', 'suggestion'), 'Submit a new suggestion.')
    @can_embed
    @on_error_reset_cooldown
    async def suggest(
        self, ctx: Circumstances,
        category: Optional[Union[TextChannel, str]],
        *, suggestion: str = '',
    ):
        """Create a suggestion."""
        if category is None:
            ctx.command.reset_cooldown(ctx)
            return await self.send_channel_list(ctx)

        if not isinstance(category, TextChannel):
            raise NotAcceptable(f'No such text channel {category}.')

        if not category.permissions_for(ctx.author).read_messages:
            raise NotAcceptable((f'You cannot submit to {tag(category)} because'
                                 ' the channel is not visible to you.'))

        target = await self.get_channel_or_404(ctx, category)
        msg = ctx.message

        suggestion = self.get_suggestion_text(target, suggestion)
        poll = Poll(suggestion, target.all_emotes, title=target.title)
        poll.set_author(ctx.author)
        poll.set_origin(msg)
        poll.single_choice = not target.voting_history

        links = self.get_suggestion_links(target, poll.get_external_links())
        files = await self.get_suggestion_files(target, msg)

        async with self._sequential, ctx.typing():

            kwargs = {'allowed_mentions': AllowedMentions.none()}
            content = self.get_preamble(target, ctx.author.id, links)
            kwargs['content'] = content
            kwargs['files'] = files or None
            linked: Message = await self.deliver(category, **kwargs)
            poll.set_linked(linked)

            submission = poll.to_embed()
            res: Message = await self.deliver(category, embed=submission)

        self.cache_submission(res.id, poll)
        await res.edit(embed=poll.to_embed(res))
        await self.add_reactions(poll, res)
        await self.respond(ctx, 'Thank you for the suggestion!')

    @suggest.command('delete', aliases=('remove', 'del', 'rm'))
    @doc.description('Delete a suggestion.')
    @doc.argument('suggestion', (
        'The message containing your submission'
        ' (copy the permalink included in the message).'
    ))
    async def suggest_delete(self, ctx: Circumstances, suggestion: Message):
        """Allow suggestion authors to remove their own suggestions.

        Otherwise it is not possible to delete the bot's message unless they have
        delete message permissions.
        """
        category: TextChannel = suggestion.channel
        poll = await self.fetch_submission(suggestion)
        if not poll.can_delete(ctx.author):
            raise NotAcceptable("You cannot delete someone else's suggestion.")
        associated = category.get_partial_message(poll.linked_msg)
        await associated.delete(delay=0)
        await suggestion.delete(delay=0)
        await self.respond(ctx, f'Deleted suggestion {code(suggestion.id)}')

    @suggest.command('edit', aliased=('update', 'change', 'set'))
    @doc.description('Edit a suggestion.')
    @doc.argument('suggestion', (
        'The message containing your submission'
        ' (copy the permalink included in the message).'
    ))
    @doc.argument('content', (
        'The updated submission; replaces the original'
        ' text content of your suggestion.'
    ))
    @doc.use_syntax_whitelist
    @doc.invocation(('suggestion', 'content'), (
        'Replace the suggestion content;'
        ' note that it is not possible'
        ' to change the uploaded files'
        ' if there are any.'
    ))
    @doc.cooldown(1, 5, BucketType.member)
    async def suggest_edit(
        self, ctx: Circumstances,
        suggestion: Message,
        *, content: str = '',
    ):
        """Allow suggestion authors to edit their suggestions."""
        poll = await self.fetch_submission(suggestion)
        if not poll.can_update(ctx.author):
            raise NotAcceptable("You cannot edit someone else's suggestion.")

        category = suggestion.channel
        target = await self.get_channel_or_404(ctx, category)

        content = self.get_suggestion_text(target, content)
        poll.edit(ctx.author, content)

        links = self.get_suggestion_links(target, poll.get_external_links())
        preamble = self.get_preamble(target, poll.author_id, links)
        await self.update_submission(poll, suggestion, linked=preamble)

        await self.respond(ctx, f'Edited suggestion {code(suggestion.id)}')

    @suggest.command('comment', aliases=('review',))
    @doc.description('Add a comment to a suggestion.')
    @doc.argument('suggestion', (
        'The message containing the submission'
        ' (copy the permalink included in the message).'
    ))
    @doc.argument('comment', 'The comment to add.')
    @doc.use_syntax_whitelist
    @doc.invocation(('suggestion', 'comment'), None)
    @doc.cooldown(1, 60, BucketType.member)
    async def comment(
        self, ctx: Circumstances,
        suggestion: Message, *, comment: str,
    ):
        """Add a comment to a suggestion."""
        if not comment:
            raise NotAcceptable('Comment must not be empty.')

        poll = await self.fetch_submission(suggestion)
        category = suggestion.channel
        target = await self.get_channel_or_404(ctx, category)

        is_arbiter = self.is_arbiter_in(target, ctx.author)
        is_public = poll.forum

        if not is_arbiter and not is_public:
            if is_public is not None:
                link = a(f'suggestion {code(suggestion.id)}', suggestion.jump_url)
                raise NotAcceptable(f'Comments section for {link} is closed.')
            else:
                raise MissingAnyRole(target.arbiters)

        poll.comment(ctx.author, comment)
        await self.update_submission(poll, suggestion)

        await self.respond(ctx, f'Comment added to suggestion {code(suggestion.id)}')

    @suggest.command('credit', aliases=('attrib',))
    @doc.description('Attribute a submission to someone else.')
    @doc.argument('suggestion', (
        'The message containing the submission'
        ' (copy the permalink included in the message).'
    ))
    @doc.argument('member', 'The member you would like to credit the suggestion to.')
    @doc.restriction(None, 'You can only change the attribution of a suggestion you submitted.')
    @doc.cooldown(1, 5, BucketType.member)
    async def suggest_credit(
        self, ctx: Circumstances,
        suggestion: Message,
        member: Member,
    ):
        """Update the author info of a suggestion to show another member.

        This is useful for when someone is submitting the suggestion on behalf
        of someone else.
        """
        poll = await self.fetch_submission(suggestion)
        if not poll.can_delete(ctx.author):
            raise NotAcceptable('You can only change the attribution of a suggestion you submitted.')

        if poll.attrib_id:
            poll.touch(ctx.author)
        poll.set_credit(member)
        await self.update_submission(poll, suggestion)

        await self.respond(ctx, f'Updated suggestion {code(suggestion.id)}')

    @suggest.command('forum')
    @doc.description('Open up the comments section of a suggestion to everyone.')
    @doc.argument('suggestion', (
        'The message containing the submission'
        ' (copy the permalink included in the message).'
    ))
    @doc.argument('enabled', 'Whether to open or close the comments section.')
    @doc.restriction(None, 'You can only change the comment access of a suggestion you submitted.')
    @doc.cooldown(1, 5, BucketType.member)
    @doc.hidden
    async def suggest_forum(
        self, ctx: Circumstances,
        suggestion: Message, enabled: bool = True,
    ):
        """Open up a suggestion as a forum.

        This would allow anyone to comment on that suggestion.
        """
        poll = await self.fetch_submission(suggestion)
        if not poll.can_delete(ctx.author):
            raise NotAcceptable('You can only change the comment access of a suggestion you submitted.')
        poll.forum = enabled
        await self.update_submission(poll, suggestion)
        res = (f'Comments section for suggestion {code(suggestion.id)} is now'
               f' {strong("on" if enabled else "off")}')
        await self.respond(ctx, res)

    @suggest.command('obfuscate')
    @doc.description('Toggle username omission in votes.')
    @doc.argument('suggestion', 'The message containing the submission.')
    @doc.hidden
    async def suggest_obfuscate(
        self, ctx: Circumstances, suggestion: Message,
    ):
        """Hide all usernames in the votes and comments section."""
        poll = await self.fetch_submission(suggestion)
        poll.obfuscated = not poll.obfuscated
        await self.update_submission(poll, suggestion)
        await self.reset_votes(poll, suggestion)
        await self.add_reactions(poll, suggestion)
        await ctx.response(ctx).success().run()

    @group('poll', case_insensitive=True, invoke_without_command=True)
    @doc.description('Make a poll.')
    @doc.argument('content', 'Question and options for the poll.', node='[poll]')
    @doc.invocation((), 'Get help on how to format your question.')
    @doc.invocation(('content',), 'Make a poll.')
    @can_embed
    async def poll(self, ctx: Circumstances, *, content: str = ''):
        """Create a poll in the current channel (independent of the suggestion system)."""
        # TODO: better errors
        HELP_TEXT = dedent("""\
        To make a poll, type the command, followed by the prompt/question of your poll: ```
        poll What's for lunch?
        ```Then, for each of your choices, **start a new line**\
            (shift-enter on desktop, on mobile look for the return key),\
            **begin with a dash `-`, and then type your option:\
            each option should be on its own line.**
        Your command should look like this: ```
        poll What's for lunch?
        - Five Guys
        - sweetgreen
        - Ippudo
        - Katz's
        - MÃ¡LÃ  Project
        ```You may have up to 10 options in your poll.
        """)
        if not content:
            res = Embed2(title='How-to use the poll command', description=HELP_TEXT)
            return await ctx.response(ctx, embed=res).autodelete(90).deleter().run()

        items: list[str] = []
        for lines in split_before(content.splitlines(), lambda s: s[:1] == '-'):
            items.append('\n'.join(lines))

        choices = items[1:]
        if not choices:
            raise NotAcceptable((
                'Cannot parse any option from your input.'
                '\nTo see how to format the command,'
                ' run it without any input.'
            ))
        if len(choices) < 2:
            raise NotAcceptable('At least 2 options are required.')
        if len(choices) > 10:
            raise NotAcceptable('You can specify at most 10 options.')

        converter = EmojiConverter()
        emotes = ('1\ufe0f\u20e3 2\ufe0f\u20e3 3\ufe0f\u20e3 4\ufe0f\u20e3 5\ufe0f\u20e3'
                  ' 6\ufe0f\u20e3 7\ufe0f\u20e3 8\ufe0f\u20e3 9\ufe0f\u20e3 ðŸ”Ÿ'
                  .split(' '))
        lines: dict[str, str] = {}
        for bullet, option in zip(emotes, choices):
            option = option.removeprefix('-').strip()
            try:
                word, *rest = option.split(' ', 1)
                emote = await converter.convert(ctx, word)
            except EmojiNotFound:
                pass
            else:
                if emote.is_usable() and str(emote) not in lines:
                    bullet = str(emote)
                    option = ' '.join(rest)
            lines[bullet] = option

        prompt = items[0]
        options = '\n'.join([f'- {emote} {line}' for emote, line in lines.items()])
        description = f'{prompt}\n{options}'

        poll = Poll(description, {k: '' for k in lines})
        poll.set_origin(ctx.message)
        poll.set_author(ctx.author)
        try:
            msg = await self.deliver(ctx.channel, embed=poll.to_embed())
        except ValueError as e:
            raise NotAcceptable(f'Your poll is too long: {e}')
        await self.add_reactions(poll, msg)
        await ctx.response(ctx).deleter().run(msg)

    @poll.command('tally', aliases=('count',))
    @doc.description('Count the votes on a poll.')
    @doc.argument('poll', 'The message containing the poll.')
    @doc.argument('anonymize', "Whether to omit vote casters' username from the result.")
    @can_embed
    async def suggest_tally(
        self, ctx: Circumstances, poll: Message,
        anonymize: Optional[Constant[Literal['anonymize']]] = False,
    ):
        """Count the votes on a submission and create a report."""
        submission = await self.fetch_submission(poll)
        res = submission.tally(poll, bool(anonymize))
        return await ctx.response(ctx, embed=res).deleter().run()

    @Gear.listener('on_raw_reaction_add')
    async def on_reaction(self, ev: RawReactionActionEvent):
        """Implement suggestion voting using Discord reactions."""
        if not ev.member:
            return
        if ev.member == self.bot.user:
            return
        if ev.message_id in self._invalid:
            return

        channel: TextChannel = self.bot.get_channel(ev.channel_id)
        if not channel:
            return
        try:
            target = await async_get(SuggestionChannel, channel_id=ev.channel_id)
        except SuggestionChannel.DoesNotExist:
            return

        target: SuggestionChannel
        emote = str(ev.emoji)
        text = target.all_emotes.get(emote)
        if not text:
            return

        if not self.is_arbiter_in(target, ev.member):
            return

        msg_id = ev.message_id
        msg = channel.get_partial_message(msg_id)
        try:
            poll = await self.fetch_submission(msg)
        except NotPoll:
            self._invalid.add(msg_id)
            return

        try:
            poll.vote(ev.member, emote)
        except ValueError:
            return

        try:
            await self.update_submission(poll, msg)
        except NotAcceptable:
            pass
        except Exception as e:
            self.log.warning(f'Error while updating reactions: {e}', exc_info=e)

    async def delete_linked_msg(self, msg_id: int, channel: TextChannel):
        """Remove the linked message (containing extra embeds and files) for this suggestion."""
        if msg_id in self._invalid:
            return
        self._invalid.add(msg_id)
        poll = self.get_cached_submission(msg_id)
        if poll is None:
            return
        linked = channel.get_partial_message(poll.linked_msg)
        self._invalid.add(linked.id)
        await linked.delete(delay=0)
        self.invalidate_submission(msg_id)

    @Gear.listener('on_raw_message_delete')
    async def on_delete(self, ev: RawMessageDeleteEvent):
        """Clean up the linked message in case the message deleted here is a submission."""
        channel: TextChannel = self.bot.get_channel(ev.channel_id)
        if not channel:
            return
        await self.delete_linked_msg(ev.message_id, channel)

    @Gear.listener('on_raw_bulk_message_delete')
    async def on_bulk_delete(self, ev: RawBulkMessageDeleteEvent):
        """Clean up the linked messages in case the messages deleted here are submissions."""
        channel: TextChannel = self.bot.get_channel(ev.channel_id)
        if not channel:
            return
        await asyncio.gather(*[
            self.delete_linked_msg(id_, channel)
            for id_ in ev.message_ids
        ])


class NotPoll(NotAcceptable):
    """`UserInputError` raised when the provided message is not a poll created by this cog."""

    def __init__(self, msg: Union[Message, PartialMessage], *args):
        link = a(f'Message {code(msg.id)}', msg.jump_url)
        message = f'{link} is not a poll submission.'
        super().__init__(message, *args)


# TODO: remove
class Invalidate(Exception):
    pass
